<!-- Site Scripts -->

<script src="https://cdn.jsdelivr.net/npm/lenis@1.2.3/dist/lenis.min.js"></script> 
<!-- Page Transition 
<script>
$(document).ready(function() {
  const wfIx = Webflow.require("ix3");
  
  // Opening animation (on load)
  wfIx.emit("transition enter");
  
  // Click animation (on link click)
  $("a:not(.excluded-class)").on("click", function (e) {
    const url = $(this).attr("href");
    
    // Link-kontrol
    if (
      $(this).prop("hostname") === window.location.hostname &&
      !url.includes("#") &&
      $(this).attr("target") !== "_blank"
    ) {
      e.preventDefault();
      
      // Start leave animation
      wfIx.emit("transition leave");
      
      // Navigate after animation duration (adjust timing as needed)
      setTimeout(() => {
        window.location.href = url;
      }, 800); // Juster dette tal til din animations varighed i ms
    }
  });
  
  // Handle back/forward navigation
  window.onpageshow = function (event) {
    if (event.persisted) window.location.reload();
  };
});
</script>

<!-- Form validator -->
<script>
function initAdvancedFormValidation(){const forms=document.querySelectorAll("[data-form-validate]");forms.forEach(formContainer=>{const startTime=(new Date).getTime(),form=formContainer.querySelector("form");if(!form)return;const validateFields=form.querySelectorAll("[data-validate]"),dataSubmit=form.querySelector("[data-submit]");if(!dataSubmit)return;const realSubmitInput=dataSubmit.querySelector('input[type="submit"]');function isSpam(){const currentTime=(new Date).getTime();return currentTime-startTime<5e3}function validateAndStartLiveValidationForAll(){let allValid=!0,firstInvalidField=null;return validateFields.forEach((function(fieldGroup){const input=fieldGroup.querySelector("input, textarea, select"),radioCheckGroup=fieldGroup.querySelector("[data-radiocheck-group]");if(input||radioCheckGroup){if(input&&(input.__validationStarted=!0),radioCheckGroup){radioCheckGroup.__validationStarted=!0;const inputs=radioCheckGroup.querySelectorAll('input[type="radio"], input[type="checkbox"]');inputs.forEach((function(input){input.__validationStarted=!0}))}updateFieldStatus(fieldGroup),isValid(fieldGroup)||(allValid=!1,firstInvalidField||(firstInvalidField=input||radioCheckGroup.querySelector("input")))}})),!allValid&&firstInvalidField&&firstInvalidField.focus(),allValid}function isValid(fieldGroup){const radioCheckGroup=fieldGroup.querySelector("[data-radiocheck-group]");if(radioCheckGroup){const inputs=radioCheckGroup.querySelectorAll('input[type="radio"], input[type="checkbox"]'),checkedInputs=radioCheckGroup.querySelectorAll("input:checked"),min=parseInt(radioCheckGroup.getAttribute("min"))||1,max=parseInt(radioCheckGroup.getAttribute("max"))||inputs.length,checkedCount=checkedInputs.length;return"radio"===inputs[0].type?checkedCount>=1:1===inputs.length?inputs[0].checked:checkedCount>=min&&checkedCount<=max}{const input=fieldGroup.querySelector("input, textarea, select");if(!input)return!1;let valid=!0;const min=parseInt(input.getAttribute("min"))||0,max=parseInt(input.getAttribute("max"))||1/0,value=input.value.trim(),length=value.length;if("select"===input.tagName.toLowerCase())""!==value&&"disabled"!==value&&"null"!==value&&"false"!==value||(valid=!1);else if("email"===input.type){const emailPattern=/^[^\s@]+@[^\s@]+\.[^\s@]+$/;valid=emailPattern.test(value)}else input.hasAttribute("min")&&length<min&&(valid=!1),input.hasAttribute("max")&&length>max&&(valid=!1);return valid}}function updateFieldStatus(fieldGroup){const radioCheckGroup=fieldGroup.querySelector("[data-radiocheck-group]");if(radioCheckGroup){const inputs=radioCheckGroup.querySelectorAll('input[type="radio"], input[type="checkbox"]'),checkedInputs=radioCheckGroup.querySelectorAll("input:checked");checkedInputs.length>0?fieldGroup.classList.add("is--filled"):fieldGroup.classList.remove("is--filled");const valid=isValid(fieldGroup);if(valid)fieldGroup.classList.add("is--success"),fieldGroup.classList.remove("is--error");else{fieldGroup.classList.remove("is--success");const anyInputValidationStarted=Array.from(inputs).some(input=>input.__validationStarted);anyInputValidationStarted?fieldGroup.classList.add("is--error"):fieldGroup.classList.remove("is--error")}}else{const input=fieldGroup.querySelector("input, textarea, select");if(!input)return;const value=input.value.trim();value?fieldGroup.classList.add("is--filled"):fieldGroup.classList.remove("is--filled");const valid=isValid(fieldGroup);valid?(fieldGroup.classList.add("is--success"),fieldGroup.classList.remove("is--error")):(fieldGroup.classList.remove("is--success"),input.__validationStarted?fieldGroup.classList.add("is--error"):fieldGroup.classList.remove("is--error"))}}realSubmitInput&&(validateFields.forEach((function(fieldGroup){const select=fieldGroup.querySelector("select");if(select){const options=select.querySelectorAll("option");options.forEach((function(option){""!==option.value&&"disabled"!==option.value&&"null"!==option.value&&"false"!==option.value||option.setAttribute("disabled","disabled")}))}})),validateFields.forEach((function(fieldGroup){const input=fieldGroup.querySelector("input, textarea, select"),radioCheckGroup=fieldGroup.querySelector("[data-radiocheck-group]");if(radioCheckGroup){const inputs=radioCheckGroup.querySelectorAll('input[type="radio"], input[type="checkbox"]');inputs.forEach((function(input){input.__validationStarted=!1,input.addEventListener("change",(function(){requestAnimationFrame((function(){if(!input.__validationStarted){const checkedCount=radioCheckGroup.querySelectorAll("input:checked").length,min=parseInt(radioCheckGroup.getAttribute("min"))||1;checkedCount>=min&&(input.__validationStarted=!0)}input.__validationStarted&&updateFieldStatus(fieldGroup)}))})),input.addEventListener("blur",(function(){input.__validationStarted=!0,updateFieldStatus(fieldGroup)}))}))}else input&&(input.__validationStarted=!1,"select"===input.tagName.toLowerCase()?input.addEventListener("change",(function(){input.__validationStarted=!0,updateFieldStatus(fieldGroup)})):(input.addEventListener("input",(function(){const value=input.value.trim(),length=value.length,min=parseInt(input.getAttribute("min"))||0,max=parseInt(input.getAttribute("max"))||1/0;input.__validationStarted||("email"===input.type?isValid(fieldGroup)&&(input.__validationStarted=!0):(input.hasAttribute("min")&&length>=min||input.hasAttribute("max")&&length<=max)&&(input.__validationStarted=!0)),input.__validationStarted&&updateFieldStatus(fieldGroup)})),input.addEventListener("blur",(function(){input.__validationStarted=!0,updateFieldStatus(fieldGroup)}))))})),dataSubmit.addEventListener("click",(function(){if(validateAndStartLiveValidationForAll()){if(isSpam())return void alert("Form submitted too quickly. Please try again.");realSubmitInput.click()}})),form.addEventListener("keydown",(function(event){if("Enter"===event.key&&"TEXTAREA"!==event.target.tagName&&(event.preventDefault(),validateAndStartLiveValidationForAll())){if(isSpam())return void alert("Form submitted too quickly. Please try again.");realSubmitInput.click()}})))})}document.addEventListener("DOMContentLoaded",()=>{initAdvancedFormValidation()});
</script>

<!-- Dropdown Menu Hover -->

<script>
  gsap.registerPlugin(SplitText);

  const items    = document.querySelectorAll('.nav_3_dropdown_link');
  const thumb    = document.getElementById('apartment-thumb');
  const address  = document.getElementById('apartment-address');
  const units    = document.getElementById('apartment-units');
  const built    = document.getElementById('apartment-built');
  const intro    = document.getElementById('apartment-text');
  const panel    = document.querySelector('.apartment-info-panel');

  const staggeredTextTargets = [intro, address, units, built];
  let splitInstances = [];
  let currentImg = '';

  function handleMouseEnter(item) {
    const newImg   = item.dataset.img;
    const newAddr  = item.dataset.address || '';
    const newUnits = item.dataset.units ? `${item.dataset.units} lejligheder` : '';
    const newBuilt = item.dataset.built ? `Opført ${item.dataset.built}` : '';
    const newIntro = item.dataset.intro || '';

    // Show image and panel
    thumb.classList.add('is--active');
    panel?.classList.add('is--active');

    // Image transition
    if (newImg && newImg !== currentImg) {
      currentImg = newImg;

      const clone = thumb.cloneNode();
      clone.src = newImg;
      Object.assign(clone.style, {
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%',
        objectFit: 'cover',
        zIndex: 2,
        opacity: 0,
        transition: 'opacity 0.4s ease'
      });

      thumb.parentElement.appendChild(clone);

      requestAnimationFrame(() => {
        clone.style.opacity = 1;
      });

      clone.addEventListener('transitionend', () => {
        thumb.src = newImg;
        clone.remove();
      }, { once: true });
    }

    // Animate text
    splitInstances.forEach(inst => inst.revert && inst.revert());
    splitInstances = [];

    intro.textContent   = newIntro;
    address.textContent = newAddr;
    units.textContent   = newUnits;
    built.textContent   = newBuilt;

    staggeredTextTargets.forEach((el, index) => {
      if (!el.textContent.trim()) return;
      gsap.set(el, { autoAlpha: 1 });

      const split = SplitText.create(el, {
        type: 'lines',
        mask: 'lines',
        autoSplit: true,
        linesClass: 'line'
      });

      gsap.from(split.lines, {
        yPercent: 110,
        duration: 0.6,
        stagger: 0.06,
        ease: 'expo.out',
        delay: 0.05 * index
      });

      splitInstances.push(split);
    });
  }

  // Hover logic
  items.forEach(item => {
    item.addEventListener('mouseenter', () => handleMouseEnter(item));
  });

  const hoverZone = document.querySelector('.nav_3_dropdown_component');
  if (hoverZone) {
    hoverZone.addEventListener('mouseleave', () => {
      thumb.classList.remove('is--active');
      panel?.classList.remove('is--active');
    });
  }
</script>

<!-- Smooth Scroll -->

<script>
// Make Lenis globally accessible for other scripts
window.lenis = new Lenis();
window.lenis.on('scroll', ScrollTrigger.update);
gsap.ticker.add((time) => {window.lenis.raf(time * 1000);});
gsap.ticker.lagSmoothing(0);


$("[data-lenis-start]").on("click", function () {
  window.lenis.start();
});
$("[data-lenis-stop]").on("click", function () {
  window.lenis.stop();
});
$("[data-lenis-toggle]").on("click", function () {
  $(this).toggleClass("stop-scroll");
  if ($(this).hasClass("stop-scroll")) {
    window.lenis.stop();
  } else {
    window.lenis.start();
  }
});
</script>


<!-- Popup Modal -->

<script>
function initBoligModal() {
  const modal = document.querySelector('[data-bolig-modal]');
  
  document.querySelectorAll('[data-bolig-modal-toggle]').forEach(btn => {
    btn.addEventListener('click', () => {
      if (!modal) return;
      const isActive = modal.getAttribute('data-bolig-modal-status') === 'active';
      modal.setAttribute('data-bolig-modal-status', isActive ? 'not-active' : 'active');
    });
  });

  document.addEventListener('keydown', event => {
    if (event.key === 'Escape' || event.keyCode === 27) {
      modal?.setAttribute('data-bolig-modal-status', 'not-active');
    }
  });
}

function initSignupModal() {
  const modal = document.querySelector('[data-signup-modal]');
  
  document.querySelectorAll('[data-signup-modal-toggle]').forEach(btn => {
    btn.addEventListener('click', () => {
      if (!modal) return;
      const isActive = modal.getAttribute('data-signup-modal-status') === 'active';
      modal.setAttribute('data-signup-modal-status', isActive ? 'not-active' : 'active');
    });
  });

  document.addEventListener('keydown', event => {
    if (event.key === 'Escape' || event.keyCode === 27) {
      modal?.setAttribute('data-signup-modal-status', 'not-active');
    }
  });
}

document.addEventListener('DOMContentLoaded', function () {
  initBoligModal();
  initSignupModal();
});
</script>

<!-- Navbar Hide on Scroll -->

<script>
function isDesktopView() {
  return window.innerWidth >= 992;
}

gsap.registerPlugin(ScrollTrigger)

let navbarScrollTrigger;

function initNavbarScrollAnimation() {
  if (isDesktopView() && !navbarScrollTrigger) {
    const navbarShowAnim = gsap.from('.navbar', {
      yPercent: -100,
      paused: true,
      duration: 0.2
    }).progress(1);

    navbarScrollTrigger = ScrollTrigger.create({
      start: "top top",
      end: 99999,
      onUpdate: (self) => {
        self.direction === -1 ? navbarShowAnim.play() : navbarShowAnim.reverse();
      }
    });
  }
}

function destroyNavbarScrollAnimation() {
  if (navbarScrollTrigger) {
    navbarScrollTrigger.kill();
    navbarScrollTrigger = null;
  }
}

window.addEventListener('resize', () => {
  if (!isDesktopView()) {
    destroyNavbarScrollAnimation();
  } else {
    initNavbarScrollAnimation();
  }
});

initNavbarScrollAnimation();

</script>



<!-- Image Slider -->
<script src="https://unpkg.com/split-type"></script>
<script>
let splitType = new SplitType(".slider_cms_title", {
    types: "words", // Split into words
    tagName: "span"
});

$(".slider_wrap").each(function () {
    let childArrow = $(this).find(".slider_btn");
    let childItems = $(this).find(".slider_cms_item").not('.w-condition-invisible').hide();
    let childDots = $(this).find(".slider_dot_item").not('.w-condition-invisible');
    let totalSlides = childItems.length;
    let activeIndex = 0;

    // Early return if no slides or dots found
    if (totalSlides === 0 || childDots.length === 0) {
        console.warn("Slider: No slides or dots found, skipping initialization");
        return;
    }

    childItems.first().css("display", "flex");
    
    // Safe GSAP set with element check
    let firstDotLine = childDots.eq(0).find(".slider_dot_line");
    if (firstDotLine.length > 0) {
        gsap.set(firstDotLine, { x: "0%" });
    }

    // DOT LINES
    let tl2 = gsap.timeline({ repeat: -1 });
    childDots.each(function (index) {
        let dotLine = $(this).find(".slider_dot_line");
        if (dotLine.length > 0) {
            tl2.addLabel(`step${index}`);
            tl2.to(dotLine, {
                scaleX: "1.0",
                ease: "none",
                duration: 5,
                onComplete: () => {
                    goNext(index + 1);
                }
            });
        }
    });

    // MAIN SLIDER CODE
    function moveSlide(nextIndex, forwards) {
        // Validate indices
        if (nextIndex < 0 || nextIndex >= totalSlides) {
            console.warn(`Slider: Invalid slide index ${nextIndex}`);
            return;
        }

        let tl3 = gsap.timeline();
        
        // Safe dot line animations
        let nextDotLine = childDots.eq(nextIndex).find(".slider_dot_line");
        let activeDotLine = childDots.eq(activeIndex).find(".slider_dot_line");
        
        if (nextDotLine.length > 0) {
            tl3.set(nextDotLine, { x: "0%" });
        }
        if (activeDotLine.length > 0) {
            tl3.fromTo(activeDotLine, { x: "0%" }, { x: "100%" });
        }

        tl2.seek(`step${nextIndex}`);

        let titleFrom = -100;
        let titleDelay = "<";
        if (forwards) {
            titleFrom = 100;
            titleDelay = "<50%";
        }
        
        childItems.hide();
        let prevItem = childItems.eq(activeIndex).css("display", "flex");
        let nextItem = childItems.eq(nextIndex).css("display", "flex");
        
        // Check if items exist before animating
        if (!prevItem.length || !nextItem.length) {
            console.warn("Slider: Slide items not found");
            return;
        }
        
        let tl = gsap.timeline({ defaults: { duration: 1, ease: "power2.inOut" } });
        
        if (forwards) {
            tl.fromTo(nextItem, { clipPath: "polygon(100% 0%, 100% 0%, 100% 100%, 100% 100%)" }, { clipPath: "polygon(0% 0%, 100% 0%, 100% 100%, -30% 100%)" });
            tl.fromTo(prevItem, { clipPath: "polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)" }, { clipPath: "polygon(0% 0%, 0% 0%, -30% 100%, 0% 100%)" }, "<");
        } else {
            tl.fromTo(nextItem, { clipPath: "polygon(0% 0%, 0% 0%, 0% 100%, 0% 100%)" }, { clipPath: "polygon(0% 0%, 100% 0%, 130% 100%, 0% 100%)" });
            tl.fromTo(prevItem, { clipPath: "polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)" }, { clipPath: "polygon(100% 0%, 100% 0%, 100% 100%, 130% 100%)" }, "<");
        }
        
        // Safe title animation with element check
        let titleWords = nextItem.find(".slider_cms_title .word");
        if (titleWords.length > 0) {
            tl.fromTo(titleWords, { yPercent: titleFrom }, { yPercent: 0, duration: 0.5, ease: "power1.inOut", stagger: { amount: 0.05 } }, titleDelay);
        }

        activeIndex = nextIndex;
    }

    // ARROWS
    function goNext(num) {
        let nextIndex = num;
        if (nextIndex > totalSlides - 1) nextIndex = 0;
        moveSlide(nextIndex, true);
    }
    
    // go next
    childArrow.filter(".is-next").on("click", function () {
        goNext(activeIndex + 1);
    });
    
    // go prev
    childArrow.filter(".is-prev").on("click", function () {
        let nextIndex = activeIndex - 1;
        if (nextIndex < 0) nextIndex = totalSlides - 1;
        moveSlide(nextIndex, false);
    });

    // CLICK OF DOTS
    childDots.on("click", function () {
        let dotIndex = $(this).index();
        if (activeIndex > dotIndex) {
            moveSlide(dotIndex, false);
        } else if (activeIndex < dotIndex) {
            moveSlide(dotIndex, true);
        }
    });
});
</script>

<!-- Page scritps -->

<script async src="https://live-cph.vercel.app/etageplan-listener.min.js"></script>
<script>
$(".scroll_horizontal_wrap").each(function (index) {
  let wrap = $(this);
  let inner = $(this).find(".scroll_horizontal_inner");
  let track = $(this).find(".scroll_horizontal_track");

  // set section height
  function setScrollDistance() {
    wrap.css("height", "calc(" + track.outerWidth() + "px + 100vh)");
  }
  setScrollDistance();
  ScrollTrigger.refresh();
  window.addEventListener("resize", setScrollDistance);

  // create main horizontal scroll timeline
  let tl = gsap.timeline({
    scrollTrigger: {
      trigger: wrap,
      start: "top top",
      end: "bottom bottom",
      scrub: true,
    },
    defaults: { ease: "none" },
  });
  tl.to(track, { xPercent: -100 });

  // get container left position
  function containerLeft() {
    return inner.offset().left + "px";
  }
  // get container right position
  function containerRight() {
    return (inner.offset().left + inner.innerWidth()) + "px";
  }

  //
  let tl2 = gsap.timeline({
    scrollTrigger: {
      trigger: $(this).find(".scroll_horizontal_hero_wrap"),
      containerAnimation: tl,
      start: "left " + containerLeft(),
      end: "right " + containerLeft(),
      scrub: true,
      // markers: true,
    },
    defaults: { ease: "none" },
  });

  //
  let tl3 = gsap.timeline({
    scrollTrigger: {
      trigger: $(this).find(".scroll_horizontal_pin_wrap"),
      containerAnimation: tl,
      start: "left " + containerLeft(),
      end: "right " + containerRight(),
      scrub: true,
      // markers: true,
    },
    defaults: { ease: "none" },
  });
  tl3.to($(this).find(".scroll_horizontal_pin_element"), { xPercent: 100 });
  // section each loop end
});
</script>


<script src="https://cdn.jsdelivr.net/gh/lumos-wf/gsap-tabs-slider@latest/dist/gsap-tabs-slider.min.js"></script>


<!-- GSAP Slider with Tab Fix -->

<script>
  gsap.registerPlugin(Draggable, InertiaPlugin);

  function initBasicGSAPSlider() {
    document.querySelectorAll('[data-gsap-slider-init]').forEach(root => {
      if (root._sliderDraggable) root._sliderDraggable.kill();

      const collection = root.querySelector('[data-gsap-slider-collection]');
      const track      = root.querySelector('[data-gsap-slider-list]');
      const items      = Array.from(root.querySelectorAll('[data-gsap-slider-item]'));
      const controls   = Array.from(root.querySelectorAll('[data-gsap-slider-control]'));

      // Inject ARIA attributes
      root.setAttribute('role','region');
      root.setAttribute('aria-roledescription','carousel');
      root.setAttribute('aria-label','Slider');
      collection.setAttribute('role','group');
      collection.setAttribute('aria-roledescription','Slides List');
      collection.setAttribute('aria-label','Slides');
      items.forEach((slide,i) => {
        slide.setAttribute('role','group');
        slide.setAttribute('aria-roledescription','Slide');
        slide.setAttribute('aria-label',`Slide ${i+1} of ${items.length}`);
        slide.setAttribute('aria-hidden','true');
        slide.setAttribute('aria-selected','false');
        slide.setAttribute('tabindex','-1');
      });
      controls.forEach(btn => {
        const dir = btn.getAttribute('data-gsap-slider-control');
        btn.setAttribute('role','button');
        btn.setAttribute('aria-label', dir==='prev' ? 'Previous Slide' : 'Next Slide');
        btn.disabled = true;
        btn.setAttribute('aria-disabled','true');
      });

      // Determine if slider runs
      const styles      = getComputedStyle(root);
      const statusVar   = styles.getPropertyValue('--slider-status').trim();
      let   spvVar      = parseFloat(styles.getPropertyValue('--slider-spv'));
      const rect        = items[0].getBoundingClientRect();
      const marginRight = parseFloat(getComputedStyle(items[0]).marginRight);
      const slideW      = rect.width + marginRight;
      if (isNaN(spvVar)) {
        spvVar = collection.clientWidth / slideW;
      }
      const spv           = Math.max(1, Math.min(spvVar, items.length));
      const sliderEnabled = statusVar==='on' && spv < items.length;
      root.setAttribute('data-gsap-slider-status', sliderEnabled ? 'active' : 'not-active');

      if (!sliderEnabled) {
        track.removeAttribute('style');
        track.onmouseenter = null;
        track.onmouseleave = null;
        items.forEach(slide => {
          slide.removeAttribute('role');
          slide.removeAttribute('aria-roledescription');
          slide.removeAttribute('aria-label');
          slide.removeAttribute('aria-hidden');
          slide.removeAttribute('aria-selected');
          slide.removeAttribute('tabindex');
          slide.removeAttribute('data-gsap-slider-item-status');
        });
        controls.forEach(btn => {
          btn.disabled = false;
          btn.removeAttribute('role');
          btn.removeAttribute('aria-label');
          btn.removeAttribute('aria-disabled');
          btn.removeAttribute('data-gsap-slider-control-status');
        });
        return;
      }

      // Hover state
      track.onmouseenter = () => track.setAttribute('data-gsap-slider-list-status','grab');
      track.onmouseleave = () => track.removeAttribute('data-gsap-slider-list-status');

      // Calculate bounds & snap points
      const vw        = collection.clientWidth;
      const tw        = track.scrollWidth;
      const maxScroll = Math.max(tw - vw, 0);
      const minX      = -maxScroll;
      const maxX      = 0;
      const maxIndex  = maxScroll / slideW;
      const full      = Math.floor(maxIndex);
      const snapPoints = [];
      for (let i = 0; i <= full; i++) snapPoints.push(-i * slideW);
      if (full < maxIndex) snapPoints.push(-maxIndex * slideW);

      let activeIndex    = 0;
      const setX         = gsap.quickSetter(track,'x','px');
      let collectionRect = collection.getBoundingClientRect();

      function updateStatus(x) {
        if (x > maxX || x < minX) return;

        const calcX = Math.max(minX, Math.min(maxX, x));
        let closest = snapPoints.reduce((prev, curr) =>
          Math.abs(curr - calcX) < Math.abs(prev - calcX) ? curr : prev
        );
        activeIndex = snapPoints.indexOf(closest);

        items.forEach((slide,i) => {
          const r           = slide.getBoundingClientRect();
          const leftEdge    = r.left - collectionRect.left;
          const slideCenter = leftEdge + r.width/2;
          const inView      = slideCenter > 0 && slideCenter < collectionRect.width;
          const status      = i === activeIndex ? 'active' : inView ? 'inview' : 'not-active';

          slide.setAttribute('data-gsap-slider-item-status', status);
          slide.setAttribute('aria-selected', i === activeIndex ? 'true' : 'false');
          slide.setAttribute('aria-hidden', inView ? 'false' : 'true');
          slide.setAttribute('tabindex', i === activeIndex ? '0' : '-1');
        });

        controls.forEach(btn => {
          const dir = btn.getAttribute('data-gsap-slider-control');
          const can = dir === 'prev' ? activeIndex > 0 : activeIndex < snapPoints.length - 1;
          btn.disabled = !can;
          btn.setAttribute('aria-disabled', can ? 'false' : 'true');
          btn.setAttribute('data-gsap-slider-control-status', can ? 'active' : 'not-active');
        });
      }

      controls.forEach(btn => {
        const dir = btn.getAttribute('data-gsap-slider-control');
        btn.addEventListener('click', () => {
          if (btn.disabled) return;
          const target = activeIndex + (dir === 'next' ? 1 : -1);
          gsap.to(track, {
            duration: 0.4,
            x: snapPoints[target],
            onUpdate: () => updateStatus(gsap.getProperty(track,'x'))
          });
        });
      });

      // Init Draggable
      root._sliderDraggable = Draggable.create(track, {
        type: 'x',
        inertia: true,
        bounds: {minX, maxX},
        throwResistance: 2000,
        dragResistance: 0.05,
        maxDuration: 0.6,
        minDuration: 0.2,
        edgeResistance: 0.75,
        snap: {x: snapPoints, duration: 0.4},
        onPress() {
          track.setAttribute('data-gsap-slider-list-status','grabbing');
          collectionRect = collection.getBoundingClientRect();
        },
        onDrag() {
          setX(this.x);
          updateStatus(this.x);
        },
        onThrowUpdate() {
          setX(this.x);
          updateStatus(this.x);
        },
        onThrowComplete() {
          setX(this.endX);
          updateStatus(this.endX);
          track.setAttribute('data-gsap-slider-list-status','grab');
        },
        onRelease() {
          setX(this.x);
          updateStatus(this.x);
          track.setAttribute('data-gsap-slider-list-status','grab');
        }
      })[0];

      // Initial state
      setX(0);
      updateStatus(0);
    });
  }

  // Reinit on resize
  function debounceOnWidthChange(fn, ms) {
    let last = innerWidth, timer;
    return function(...args) {
      clearTimeout(timer);
      timer = setTimeout(() => {
        if (innerWidth !== last) {
          last = innerWidth;
          fn.apply(this, args);
        }
      }, ms);
    };
  }

  window.addEventListener('resize', debounceOnWidthChange(initBasicGSAPSlider, 200));

  // Init on DOM ready
  document.addEventListener('DOMContentLoaded', function() {
    initBasicGSAPSlider();
  });

  // ✅ Fix: Reinit on tab click (Webflow Tabs)
  document.querySelectorAll('.w-tab-link').forEach(tab => {
    tab.addEventListener('click', () => {
      setTimeout(() => {
        initBasicGSAPSlider();
      }, 50); // slight delay for DOM render
    });
  });
</script>

<script>
  document.querySelectorAll('.w-tab-link').forEach(tab => {
    tab.addEventListener('click', () => {
      setTimeout(() => {
        document.querySelectorAll('[data-gsap-slider-init]').forEach(el => {
          if (!el.classList.contains('gsap-slider-initialized')) {
            window.gsapTabsSlider.init(el);
          }
        });
      }, 300); // Wait for Webflow tab to become visible
    });
  });
</script>



<script>
function initTabSystem() {
  const wrappers = document.querySelectorAll('[data-tabs="wrapper"]');
  
  wrappers.forEach((wrapper) => {
    const contentItems = wrapper.querySelectorAll('[data-tabs="content-item"]');
    const visualItems = wrapper.querySelectorAll('[data-tabs="visual-item"]');
    
    const autoplay = wrapper.dataset.tabsAutoplay === "true";
    const autoplayDuration = parseInt(wrapper.dataset.tabsAutoplayDuration) || 5000;
    
    let activeContent = null; // keep track of active item/link
    let activeVisual = null;
    let isAnimating = false;
    let progressBarTween = null; // to stop/start the progress bar

    function startProgressBar(index) {
      if (progressBarTween) progressBarTween.kill();
      const bar = contentItems[index].querySelector('[data-tabs="item-progress"]');
      if (!bar) return;
      
      gsap.set(bar, { scaleX: 0, transformOrigin: "left center" });
      progressBarTween = gsap.to(bar, {
        scaleX: 1,
        duration: autoplayDuration / 1000,
        ease: "power1.inOut",
        onComplete: () => {
          if (!isAnimating) {
            const nextIndex = (index + 1) % contentItems.length;
            switchTab(nextIndex); // once bar is full, set next to active – this is important
          }
        },
      });
    }

    function switchTab(index) {
      if (isAnimating || contentItems[index] === activeContent) return;
      
      isAnimating = true;
      if (progressBarTween) progressBarTween.kill(); // Stop any running progress bar here
      
      const outgoingContent = activeContent;
      const outgoingVisual = activeVisual;
      const outgoingBar = outgoingContent?.querySelector('[data-tabs="item-progress"]');
      
      const incomingContent = contentItems[index];
      const incomingVisual = visualItems[index];
      const incomingBar = incomingContent.querySelector('[data-tabs="item-progress"]');
      
      outgoingContent?.classList.remove("active");
      outgoingVisual?.classList.remove("active");
      incomingContent.classList.add("active");
      incomingVisual.classList.add("active");
      
      const tl = gsap.timeline({
        defaults: { duration: 0.65, ease: "power3" },
        onComplete: () => {
          activeContent = incomingContent;
          activeVisual = incomingVisual;
          isAnimating = false;
          if (autoplay) startProgressBar(index); // Start autoplay bar here
        },
      });
      
      // Wrap 'outgoing' in a check to prevent warnings on first run of the function
      // Of course, during first run (on page load), there's no 'outgoing' tab yet!
      if (outgoingContent) {
        outgoingContent.classList.remove("active");
        outgoingVisual?.classList.remove("active");
        tl.set(outgoingBar, { transformOrigin: "right center" })
          .to(outgoingBar, { scaleX: 0, duration: 0.3 }, 0)
          .to(outgoingVisual, { autoAlpha: 0, xPercent: 3 }, 0)
          .to(outgoingContent.querySelector('[data-tabs="item-details"]'), { height: 0 }, 0);
      }

      incomingContent.classList.add("active");
      incomingVisual.classList.add("active");
      tl.fromTo(incomingVisual, { autoAlpha: 0, xPercent: 3 }, { autoAlpha: 1, xPercent: 0 }, 0.3)
        .fromTo( incomingContent.querySelector('[data-tabs="item-details"]'),{ height: 0 },{ height: "auto" },0)
        .set(incomingBar, { scaleX: 0, transformOrigin: "left center" }, 0);
    }

    // on page load, set first to active
    // idea: you could wrap this in a scrollTrigger
    // so it will only start once a user reaches this section
    switchTab(0);
    
    // switch tabs on click
    contentItems.forEach((item, i) =>
      item.addEventListener("click", () => {
        if (item === activeContent) return; // ignore click if current one is already active
        switchTab(i);
      })
    );
    
  });
}

// Initialize Tab System with Autoplay Option
document.addEventListener('DOMContentLoaded', () => {
  initTabSystem();
});
</script>

<!-- Updates etageoversigt tabs based on conditional visibility -->
<script>
(function() {
  'use strict';
  
  function setFirstVisibleTabActive() {
    try {
      const tabContainer = document.querySelector('.floor_tabs');
      if (!tabContainer) return;
      
      const tabLinks = tabContainer.querySelectorAll('._w-tab-link');
      const tabPanes = tabContainer.querySelectorAll('.w-tab-pane');
      
      if (tabLinks.length === 0 || tabPanes.length === 0) return;
      
      // Find den første synlige tab-link
      const firstVisibleTabLink = Array.from(tabLinks).find(link => 
        !link.classList.contains('w-condition-invisible')
      );
      
      if (!firstVisibleTabLink) return;
      
      const targetTabValue = firstVisibleTabLink.getAttribute('data-w-tab');
      if (!targetTabValue) return;
      
      // Find den tilsvarende tab-pane
      const targetTabPane = Array.from(tabPanes).find(pane => 
        pane.getAttribute('data-w-tab') === targetTabValue
      );
      
      if (!targetTabPane) return;
      
      // Tjek om den rigtige tab allerede er aktiv
      if (firstVisibleTabLink.classList.contains('w--current') && 
          targetTabPane.classList.contains('w--tab-active')) {
        return;
      }
      
      // Fjern aktive klasser
      tabLinks.forEach(link => {
        link.classList.remove('w--current');
        link.setAttribute('aria-selected', 'false');
        if (link !== firstVisibleTabLink) {
          link.setAttribute('tabindex', '-1');
        }
      });
      
      tabPanes.forEach(pane => {
        pane.classList.remove('w--tab-active');
        pane.style.opacity = '';
        pane.style.transition = '';
      });
      
      // Tilføj aktive klasser
      firstVisibleTabLink.classList.add('w--current');
      firstVisibleTabLink.setAttribute('aria-selected', 'true');
      firstVisibleTabLink.removeAttribute('tabindex');
      
      targetTabPane.classList.add('w--tab-active');
      targetTabPane.style.opacity = '1';
      targetTabPane.style.transition = 'all, opacity 300ms';
      
      // Opdater data-current
      tabContainer.setAttribute('data-current', targetTabValue);
      
      // Registrer click events på alle synlige tabs for at sikre de virker
      tabLinks.forEach(link => {
        if (!link.classList.contains('w-condition-invisible')) {
          // Fjern eksisterende event listeners først
          link.removeEventListener('click', handleTabClick);
          // Tilføj ny event listener
          link.addEventListener('click', handleTabClick);
        }
      });
      
    } catch (error) {
      console.warn('Tab visibility script error:', error);
    }
  }
  
  function handleTabClick(e) {
    // Lad Webflow håndtere click'et naturligt
    // Dette sikrer at Webflow's native funktionalitet ikke bliver brudt
  }
  
  // Vent på at Webflow's scripts er loaded
  function waitForWebflow() {
    return new Promise((resolve) => {
      // Tjek om Webflow object eksisterer
      if (typeof window.Webflow !== 'undefined') {
        resolve();
        return;
      }
      
      // Ellers vent indtil det er loaded
      const checkInterval = setInterval(() => {
        if (typeof window.Webflow !== 'undefined') {
          clearInterval(checkInterval);
          resolve();
        }
      }, 50);
      
      // Timeout efter 5 sekunder
      setTimeout(() => {
        clearInterval(checkInterval);
        resolve();
      }, 5000);
    });
  }
  
  async function initialize() {
    // Vent på Webflow
    await waitForWebflow();
    
    // Ekstra forsinkelse for at sikre alt er klart
    setTimeout(() => {
      setFirstVisibleTabActive();
      
      // Trigger Webflow's ready event hvis nødvendigt
      if (window.Webflow && window.Webflow.ready) {
        window.Webflow.ready();
      }
    }, 200);
  }
  
  // Multiple event listeners for at sikre det kører
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initialize);
  } else {
    initialize();
  }
  
  // Også når alt er loaded
  window.addEventListener('load', () => {
    setTimeout(initialize, 100);
  });
  
})();
</script>